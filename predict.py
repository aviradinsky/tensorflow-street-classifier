# %%

from matplotlib import pyplot as plt
from tensorflow import keras

from PIL import Image
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential

import tensorflow.keras.preprocessing.image as tfim
import tensorflow_datasets as tfds
import tensorflow as tf
import numpy as np
import cv2 as cv
import random
import sys
import os

import scale_and_slide as sas

# %%

classes = {
    0:   'bike',
    1:   'motorcycle',
    2:   'bus',
    3:   'truck',
    4:   'car',
    5:   'train',
    6:   'person',
    7:   'traffic light',
    8:   'stop sign',
    9:   'fire hydrant',
    10: 'background'
}

# %%

def display_image(image):
    plt.imshow(image)
    plt.axis('off')
    plt.show()
# %%

def load_model(filepath, show_summary=True):
    """Get the model stored at the given filepath

    Args:
        filepath (str): path to the model stored.
        show_summary (bool, optional): display summary of the model's
                                       architecture. Defaults to True.

    Returns:
        tf.keras.Model: the model
    """
    # load the model
    model = tf.keras.models.load_model('saved_model/my_model')
    if show_summary:
        # Check its architecture
        model.summary()
    return model

# %%
def get_crops(image: Image.Image, size: tuple, stride: int):
    """Get the crops and accompanying bounding boxes of a given image
    generated by pyramid scaling and sliding windows.

    Args:
        image (Image.Image): image to crop.
        size (tuple): target crop size.
        stride (int): sliding window stride.

    Returns:
        list, list: a list of numpy arrays of images and a list of
                    the corresponding bounding boxes of the crops on 
                    the original image.
    """
    crops_pairs = sas.get_image_chunks(image, size, stride)
    zipped = list(zip(*crops_pairs))
    crops = list(zipped[0])
    locations = list(zipped[1])
    return crops, locations

# %%
def predict(model_path: str, image: Image.Image, 
            crop_dims: tuple, stride: int):
    """Display bounding boxes and labels detected by the given model 
    on the given image.

    Args:
        model_path (str): path to model.
        image (Image.Image): image for the model to predict.
        crop_dims (tuple): dimensions of sliding window crops.
        stride (int): sliding window stride.
    """
    model = load_model(model_path)

    # resize image to width of 750 px, and proportional height
    factor = 750 / image.width
    size = (int(image.width * factor), int(image.height * factor))
    test_image = image.resize(size)
    display_image(test_image)
    # get crops and locations
    crops, locations = get_crops(test_image, crop_dims, stride)
    # find and resize images to model input size
    in_tensor = keras.backend.int_shape(model.layers[0].input)
    input_size = (in_tensor[1], in_tensor[2], in_tensor[3])
   
    for i, crop in enumerate(crops):
        im = Image.fromarray(np.uint8(crop)).convert('RGB')
        im = im.resize((input_size[0], input_size[1]))
        crops[i] = np.array(im)

    # run predict on each crop
    print ('len crops: ' + str(len(crops)))
    tally = 0
    cutoff = .85
    # keep track of crops that meet cutoff
    top_preds = []

    for i, crop in enumerate(crops):
        crop_tensor = tf.expand_dims(crop, 0)
        predictions = model.predict(crop_tensor)
        score = tf.nn.softmax(predictions)
        im_class = classes[np.argmax(score)]
        # store crop if probability meets the cutoff
        if tf.reduce_max(score).numpy() >= cutoff:
            top_preds.append((crop, locations[i], im_class))
            tally += 1

    print(f'total crops with prob > {cutoff}: ', tally)

    # randomly display the best crops with bboxes and labels
    random.shuffle(top_preds)
    # draw bounding boxes on original image
    img_array = np.array(test_image.copy())

    for i, location in enumerate(top_preds):
        # create color of bounding box (at random)
        # print(location[1])
        colors = []
        for _ in range(3):
            colors.append(random.randint(0,255))

        if i < 10:    
            # locations are in order of (left, top, right, bottom)
            top_left = (location[1][0], location[1][1])
            bottom_right = (location[1][2], location[1][3])
            img_array = cv.rectangle(img_array, pt1=top_left, pt2=bottom_right,
                                    color=tuple(colors), thickness=4)
            txt_pos = (top_left[0], bottom_right[1] + 20)
            cv.putText(img_array, location[2], txt_pos, cv.FONT_HERSHEY_DUPLEX, 1,(0,0,0),2)
        else:
            break

    display_image(img_array)

# %%

def test():
    # get test image
    home_dir = os.path.expanduser('~')
    test_dir = f'{home_dir}/tensorflow_datasets/downloads/extracted'\
            + '/ZIP.images.cocodataset.org_zips_test2015GiqolrgR'\
            + 'QKhQp4-ov_B9RVaY0qvzZP8FchdjRYqBAco.zip/test2015'
    im_name = 'COCO_test2015_000000113841.jpg'
    full_path = test_dir + '/' + im_name
    test_image = Image.open(full_path)

    model_path = 'saved_model/my_model'
    crop_dims = (65,100)
    stride = 40
    
    predict(model_path, test_image, crop_dims, stride)

# %%

if __name__ == '__main__':
    test()

# %%
